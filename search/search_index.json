{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"[ ] 15 [ ] 13 [ ] 13 [ ] 18 Dark magics about variable names in python Change Log | API Installation pip install varname Features Fetching variable names from inside the function/class call using varname Fetching variable names directly using nameof A value wrapper to store the variable name that a value is assigned to using Wrapper Detecting next immediate attribute name using will Injecting __varname__ to classes A debug function to print variables with their names and values. Credits Thanks goes to these awesome people/projects: @alexmojaki executing Special thanks to @HanyuuLu to give up the name varname in pypi for this project. Usage Retrieving the variable names from inside a function call/class instantiation From insdie a function call from varname import varname def function (): return varname () func = function () # func == 'func' varname calls being buried deeply def function (): # I know that at which frame this will be called return varname ( 3 ) # with v0.5.6+ now you can also specify a list of intermediate # calls to be ignored in counting: # module = sys.modules[__name__] # return varname(ignore=[(module, 'function1'), (module, 'function2)]) def function1 (): return function () def function2 (): return function1 () func = function2 () # func == 'func' varname in type annotation or async context import typing class Foo : def __init__ ( self ): self . id = varname ( ignore = [ typing ]) foo : Foo = Foo () # foo.id == 'foo' import asyncio async def func (): return varname ( ignore = [ asyncio ]) x = asyncio . run ( func ()) # x == 'x' Retrieving instance name of a class class Foo : def __init__ ( self ): self . id = varname () def copy ( self ): # also able to fetch inside a method call copied = Foo () # copied.id == 'copied' copied . id = varname () # assign id to whatever variable name return copied k = Foo () # k.id == 'k' # see also register __varname__ to classes k2 = k . copy () # k2.id == 'k2' Multiple variables on Left-hand side # since v0.5.4 def func (): return varname ( multi_vars = True ) a = func () # a == ('a', ) a , b = func () # (a, b) == ('a', 'b') [ a , b ] = func () # (a, b) == ('a', 'b') # hierarchy is also possible a , ( b , c ) = func () # (a, b, c) == ('a', 'b', 'c') Some unusual use func = [ function ()] # func == ['func'] func = [ function (), function ()] # func == ['func', 'func'] func = function (), function () # func = ('func', 'func') func = func1 = function () # func == func1 == 'func' # a warning will be printed # since you may not want func1 to be 'func' x = func ( y = func ()) # x == 'x' # get part of the name func_abc = function ()[ - 3 :] # func_abc == 'abc' # function alias supported now function2 = function func = function2 () # func == 'func' a = lambda : 0 a . b = function () # a.b == 'b' # Since v0.1.3 # We can ask varname to raise exceptions # if it fails to detect the variable name def get_name ( raise_exc ): return varname ( raise_exc = raise_exc ) a = {} a [ 'b' ] = get_name ( True ) # VarnameRetrievingError a [ 'b' ] = get_name ( False ) # None Value wrapper from varname import Wrapper foo = Wrapper ( True ) # foo.name == 'foo' # foo.value == True bar = Wrapper ( False ) # bar.name == 'bar' # bar.value == False def values_to_dict ( * args ): return { val . name : val . value for val in args } mydict = values_to_dict ( foo , bar ) # {'foo': True, 'bar': False} Getting variable names directly from varname import varname , nameof a = 1 nameof ( a ) # 'a' b = 2 nameof ( a , b ) # ('a', 'b') def func (): return varname () + '_suffix' f = func () # f == 'f_suffix' nameof ( f ) # 'f' # get full names of (chained) attribute calls func . a = func nameof ( func . a , full = True ) # 'func.a' func . a . b = 1 nameof ( func . a . b , full = True ) # 'func.a.b' Detecting next immediate attribute name from varname import will class AwesomeClass : def __init__ ( self ): self . will = None def permit ( self ): self . will = will ( raise_exc = False ) if self . will == 'do' : # let self handle do return self raise AttributeError ( 'Should do something with AwesomeClass object' ) def do ( self ): if self . will != 'do' : raise AttributeError ( \"You don't have permission to do\" ) return 'I am doing!' awesome = AwesomeClass () awesome . do () # AttributeError: You don't have permission to do awesome . permit () # AttributeError: Should do something with AwesomeClass object awesome . permit () . do () == 'I am doing!' Register __varname__ to classes from varname import register @register class Dict ( dict ): pass a = Dict ( a = 1 ) b = Dict ( b = 2 ) a . __varname__ == 'a' b . __varname__ == 'b' a . update ( b ) a == { 'a' : 1 , 'b' : 2 } Debugging with debug a = 'value' b = object () debug ( a ) # DEBUG: a='value' debug ( b ) # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b ) # DEBUG: a='value' # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b , merge = True ) # DEBUG: a='value', b=<object object at 0x2b70580e5f20> debug ( a , repr = False , prefix = '' ) # a=value Reliability and limitations varname is all depending on executing package to look for the node. The node executing detects is ensured to be the correct one (see this ). It partially works with environments where other AST magics apply, including pytest , ipython , macropy , birdseye , reticulate with R , etc. Neither executing nor varname is 100% working with those environments. Use it at your own risk. For example: This will not work with pytest : a = 1 assert nameof ( a ) == 'a' # do this instead name_a = nameof ( a ) assert name_a == 'a' R with reticulate .","title":"Home"},{"location":"#installation","text":"pip install varname","title":"Installation"},{"location":"#features","text":"Fetching variable names from inside the function/class call using varname Fetching variable names directly using nameof A value wrapper to store the variable name that a value is assigned to using Wrapper Detecting next immediate attribute name using will Injecting __varname__ to classes A debug function to print variables with their names and values.","title":"Features"},{"location":"#credits","text":"Thanks goes to these awesome people/projects: @alexmojaki executing Special thanks to @HanyuuLu to give up the name varname in pypi for this project.","title":"Credits"},{"location":"#usage","text":"","title":"Usage"},{"location":"#retrieving-the-variable-names-from-inside-a-function-callclass-instantiation","text":"From insdie a function call from varname import varname def function (): return varname () func = function () # func == 'func' varname calls being buried deeply def function (): # I know that at which frame this will be called return varname ( 3 ) # with v0.5.6+ now you can also specify a list of intermediate # calls to be ignored in counting: # module = sys.modules[__name__] # return varname(ignore=[(module, 'function1'), (module, 'function2)]) def function1 (): return function () def function2 (): return function1 () func = function2 () # func == 'func' varname in type annotation or async context import typing class Foo : def __init__ ( self ): self . id = varname ( ignore = [ typing ]) foo : Foo = Foo () # foo.id == 'foo' import asyncio async def func (): return varname ( ignore = [ asyncio ]) x = asyncio . run ( func ()) # x == 'x' Retrieving instance name of a class class Foo : def __init__ ( self ): self . id = varname () def copy ( self ): # also able to fetch inside a method call copied = Foo () # copied.id == 'copied' copied . id = varname () # assign id to whatever variable name return copied k = Foo () # k.id == 'k' # see also register __varname__ to classes k2 = k . copy () # k2.id == 'k2' Multiple variables on Left-hand side # since v0.5.4 def func (): return varname ( multi_vars = True ) a = func () # a == ('a', ) a , b = func () # (a, b) == ('a', 'b') [ a , b ] = func () # (a, b) == ('a', 'b') # hierarchy is also possible a , ( b , c ) = func () # (a, b, c) == ('a', 'b', 'c') Some unusual use func = [ function ()] # func == ['func'] func = [ function (), function ()] # func == ['func', 'func'] func = function (), function () # func = ('func', 'func') func = func1 = function () # func == func1 == 'func' # a warning will be printed # since you may not want func1 to be 'func' x = func ( y = func ()) # x == 'x' # get part of the name func_abc = function ()[ - 3 :] # func_abc == 'abc' # function alias supported now function2 = function func = function2 () # func == 'func' a = lambda : 0 a . b = function () # a.b == 'b' # Since v0.1.3 # We can ask varname to raise exceptions # if it fails to detect the variable name def get_name ( raise_exc ): return varname ( raise_exc = raise_exc ) a = {} a [ 'b' ] = get_name ( True ) # VarnameRetrievingError a [ 'b' ] = get_name ( False ) # None","title":"Retrieving the variable names from inside a function call/class instantiation"},{"location":"#value-wrapper","text":"from varname import Wrapper foo = Wrapper ( True ) # foo.name == 'foo' # foo.value == True bar = Wrapper ( False ) # bar.name == 'bar' # bar.value == False def values_to_dict ( * args ): return { val . name : val . value for val in args } mydict = values_to_dict ( foo , bar ) # {'foo': True, 'bar': False}","title":"Value wrapper"},{"location":"#getting-variable-names-directly","text":"from varname import varname , nameof a = 1 nameof ( a ) # 'a' b = 2 nameof ( a , b ) # ('a', 'b') def func (): return varname () + '_suffix' f = func () # f == 'f_suffix' nameof ( f ) # 'f' # get full names of (chained) attribute calls func . a = func nameof ( func . a , full = True ) # 'func.a' func . a . b = 1 nameof ( func . a . b , full = True ) # 'func.a.b'","title":"Getting variable names directly"},{"location":"#detecting-next-immediate-attribute-name","text":"from varname import will class AwesomeClass : def __init__ ( self ): self . will = None def permit ( self ): self . will = will ( raise_exc = False ) if self . will == 'do' : # let self handle do return self raise AttributeError ( 'Should do something with AwesomeClass object' ) def do ( self ): if self . will != 'do' : raise AttributeError ( \"You don't have permission to do\" ) return 'I am doing!' awesome = AwesomeClass () awesome . do () # AttributeError: You don't have permission to do awesome . permit () # AttributeError: Should do something with AwesomeClass object awesome . permit () . do () == 'I am doing!'","title":"Detecting next immediate attribute name"},{"location":"#register-__varname__-to-classes","text":"from varname import register @register class Dict ( dict ): pass a = Dict ( a = 1 ) b = Dict ( b = 2 ) a . __varname__ == 'a' b . __varname__ == 'b' a . update ( b ) a == { 'a' : 1 , 'b' : 2 }","title":"Register __varname__ to classes"},{"location":"#debugging-with-debug","text":"a = 'value' b = object () debug ( a ) # DEBUG: a='value' debug ( b ) # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b ) # DEBUG: a='value' # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b , merge = True ) # DEBUG: a='value', b=<object object at 0x2b70580e5f20> debug ( a , repr = False , prefix = '' ) # a=value","title":"Debugging with debug"},{"location":"#reliability-and-limitations","text":"varname is all depending on executing package to look for the node. The node executing detects is ensured to be the correct one (see this ). It partially works with environments where other AST magics apply, including pytest , ipython , macropy , birdseye , reticulate with R , etc. Neither executing nor varname is 100% working with those environments. Use it at your own risk. For example: This will not work with pytest : a = 1 assert nameof ( a ) == 'a' # do this instead name_a = nameof ( a ) assert name_a == 'a' R with reticulate .","title":"Reliability and limitations"},{"location":"CHANGELOG/","text":"v0.5.6 Add ignore argument to varname to ignore frames that are not counted by caller Deprecate inject_varname , use register instead v0.5.5 Deprecate inject and use inject_varname decorator instead v0.5.4 Allow varname.varname to receive multiple variables on the left-hand side v0.5.3 Add debug function Deprecate namedtuple (will be removed in 0.6.0 ) v0.5.2 Move messaging of weird nameof calls from _bytecode_nameof to nameof . Disallow full to be used when _bytecode_nameof needs to be invoked. v0.5.1 Add better messaging for weird nameof calls v0.5.0 Allow nameof to retrieve full name of chained attribute calls Add __all__ to the module so that only desired APIs are exposed when from varname import * Give more hints on nameof being called in a weird way when no soucecode available. v0.4.0 Change default of raise_exc to True for all related APIs Deprecate var_0 Get rid of VarnameRetrievingWarning . v0.3.0 Use sys._getframe instead of inspect.stack for efficiency (#9) Add alternative way of testing bytecode nameof (#10) Drop support for pytest, don't try to find node when executing fails Remodel will for better logic Support attributes in varname and nameof (#14) v0.2.0 Fix #5 and fit nameof in more cases v0.1.7 Add inject function v0.1.6 Fit situations when frames cannot be fetched Add shortcut for namedtuple v0.1.5 Fix will from a property call v0.1.4 Add will to detect next immediate attribute name v0.1.3 Add arugment raise_exc for varname to raise an exception instead of returning var_<index> v0.1.2 Add function nameof v0.1.1 Add a value wrapper Wrapper class v0.1.0 Implement varname function","title":"Change Log"},{"location":"CHANGELOG/#v056","text":"Add ignore argument to varname to ignore frames that are not counted by caller Deprecate inject_varname , use register instead","title":"v0.5.6"},{"location":"CHANGELOG/#v055","text":"Deprecate inject and use inject_varname decorator instead","title":"v0.5.5"},{"location":"CHANGELOG/#v054","text":"Allow varname.varname to receive multiple variables on the left-hand side","title":"v0.5.4"},{"location":"CHANGELOG/#v053","text":"Add debug function Deprecate namedtuple (will be removed in 0.6.0 )","title":"v0.5.3"},{"location":"CHANGELOG/#v052","text":"Move messaging of weird nameof calls from _bytecode_nameof to nameof . Disallow full to be used when _bytecode_nameof needs to be invoked.","title":"v0.5.2"},{"location":"CHANGELOG/#v051","text":"Add better messaging for weird nameof calls","title":"v0.5.1"},{"location":"CHANGELOG/#v050","text":"Allow nameof to retrieve full name of chained attribute calls Add __all__ to the module so that only desired APIs are exposed when from varname import * Give more hints on nameof being called in a weird way when no soucecode available.","title":"v0.5.0"},{"location":"CHANGELOG/#v040","text":"Change default of raise_exc to True for all related APIs Deprecate var_0 Get rid of VarnameRetrievingWarning .","title":"v0.4.0"},{"location":"CHANGELOG/#v030","text":"Use sys._getframe instead of inspect.stack for efficiency (#9) Add alternative way of testing bytecode nameof (#10) Drop support for pytest, don't try to find node when executing fails Remodel will for better logic Support attributes in varname and nameof (#14)","title":"v0.3.0"},{"location":"CHANGELOG/#v020","text":"Fix #5 and fit nameof in more cases","title":"v0.2.0"},{"location":"CHANGELOG/#v017","text":"Add inject function","title":"v0.1.7"},{"location":"CHANGELOG/#v016","text":"Fit situations when frames cannot be fetched Add shortcut for namedtuple","title":"v0.1.6"},{"location":"CHANGELOG/#v015","text":"Fix will from a property call","title":"v0.1.5"},{"location":"CHANGELOG/#v014","text":"Add will to detect next immediate attribute name","title":"v0.1.4"},{"location":"CHANGELOG/#v013","text":"Add arugment raise_exc for varname to raise an exception instead of returning var_<index>","title":"v0.1.3"},{"location":"CHANGELOG/#v012","text":"Add function nameof","title":"v0.1.2"},{"location":"CHANGELOG/#v011","text":"Add a value wrapper Wrapper class","title":"v0.1.1"},{"location":"CHANGELOG/#v010","text":"Implement varname function","title":"v0.1.0"},{"location":"api/varname/","text":"module varname </> Dark magics about variable name in python Classes VarnameRetrievingError \u2014 When failed to retrieve the varname </> Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr ) \u2014 Print variable names and values. </> inject ( obj ) (object) \u2014 Inject attribute __varname__ to an object </> inject_varname ( cls , caller , multi_vars , raise_exc ) (Union(type, callable(type: type))) \u2014 Alias of register. Will be deprecated </> namedtuple ( *args , **kwargs ) (type) \u2014 A shortcut for namedtuple </> nameof ( var , *more_vars , caller , full ) (str or (str)) \u2014 Get the names of the variables passed in </> register ( cls , caller , multi_vars , raise_exc ) (Union(type, callable(type: type))) \u2014 A decorator to inject varname attribute to a class </> varname ( caller , ignore , multi_vars , raise_exc ) (Union(str, (str or tuple), nonetype)) \u2014 Get the variable name that assigned by function/class calls </> will ( caller , raise_exc ) (str, optional) \u2014 Detect the attribute name right immediately after a function call. </> class varname . VarnameRetrievingError ( ) </> Bases Exception BaseException When failed to retrieve the varname function varname . varname ( caller=1 , ignore=None , multi_vars=False , raise_exc=True ) </> Get the variable name that assigned by function/class calls To debug and specify the right caller and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> import varname >>> varname . DEBUG = True Parameters caller (int, optional) \u2014 The call frame index, indicating where this function is called relative to where the variable is finally retrieved Frames are counted with the ignored ones being excluded. See ignore for frames to be ignored. ignore (list of Union(module, (module, str)), optional) \u2014 A list of modules or tuples of module and qualname that you want to ignore for the intermediate calls. For example, ['module'] ignores all intermediate calls from module and its submodules, but [(module, 'func')] only ignores the calls (qual)named func from module . By default, all calls from varname and builtin modules (in sys.builtin_module_names ) are ignored. Note that the qualname in the module should exist and be unique. multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS). If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Returns (Union(str, (str or tuple), nonetype)) The variable name, or None when raise_exc is False and we failed to retrieve the variable name. A tuple or a hierarchy (tuple of tuples) of variable names when multi_vars is True . Raises UserWarning \u2014 When there are multiple target in the assign node. (e.g: a = b = func() , in such a case, b == 'a' , may not be the case you want) VarnameRetrievingError \u2014 When there is invalid variables or invalid number of variables used on the LHS; or when we are unable to retrieve the variable name and raise_exc is set to True . function varname . will ( caller=1 , raise_exc=True ) </> Detect the attribute name right immediately after a function call. Examples >>> class AwesomeClass : >>> def __init__ ( self ): >>> self . will = None >>> def permit ( self ): >>> self . will = will () >>> if self . will == 'do' : >>> # let self handle do >>> return self >>> raise AttributeError ( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do ( self ): >>> if self . will != 'do' : >>> raise AttributeError ( \"You don't have permission to do\" ) >>> return 'I am doing!' >>> awesome = AwesomeClass () >>> # AttributeError: You don't have permission to do >>> awesome . do () >>> # AttributeError: Should do something with AwesomeClass object >>> awesome . permit () >>> awesome . permit () . do () == 'I am doing!' Parameters caller (int, optional) \u2014 At which stack this function is called. raise_exc (bool, optional) \u2014 Raise exception we failed to detect Returns (str, optional) The attribute name right after the function call If there is no attribute attached and raise_exc is False Raises VarnameRetrievingError \u2014 When raise_exc is True and we failed to detect the attribute name (including not having one) function varname . register ( cls=None , caller=1 , multi_vars=False , raise_exc=True ) </> A decorator to inject varname attribute to a class Parameters caller (int, optional) \u2014 The call stack index, indicating where this class is instantiated relative to where the variable is finally retrieved multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS). If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Examples >>> @varname . register >>> class Foo : pass >>> foo = Foo () >>> # foo.__varname__ == 'foo' Returns (Union(type, callable(type: type))) The wrapper function or the class itself if it is specified explictly. function varname . inject_varname ( cls=None , caller=1 , multi_vars=False , raise_exc=True ) \u2192 Union(type, callable(type: type)) </> Alias of register. Will be deprecated function varname . inject ( obj ) </> Inject attribute __varname__ to an object Examples >>> class MyList ( list ): >>> pass >>> a = varname . inject ( MyList ()) >>> b = varname . inject ( MyList ()) >>> a . __varname__ == 'a' >>> b . __varname__ == 'b' >>> a == b >>> # other methods not affected >>> a . append ( 1 ) >>> b . append ( 1 ) >>> a == b Parameters obj (object) \u2014 An object that can be injected Raises VarnameRetrievingError \u2014 When __varname__ is unable to be set as an attribute Returns (object) The object with varname injected function varname . nameof ( var , *more_vars , caller=1 , full=None ) </> Get the names of the variables passed in Examples >>> a = 1 >>> nameof ( a ) # 'a' >>> b = 2 >>> nameof ( a , b ) # ('a', 'b') >>> x = lambda : None >>> x . y = 1 >>> nameof ( x . y , full = True ) # 'x.y' Note This function works with the environments where source code is available, in other words, the callee's node can be retrieved by executing . In some cases, for example, running code from python shell/REPL or from exec / eval , we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Parameters var \u2014 The variable to retrieve the name of *more_vars \u2014 Other variables to retrieve the names of caller (int, optional) \u2014 The depth of the caller (this function) is called. This is useful if you want to wrap this function. Note that the calls from varname and builtin modules are ignored. full (bool, optional) \u2014 Whether report the full path of the variable. For example: nameof(a.b.c, full=True) give you a.b.c instead of c Returns (str or (str)) The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises VarnameRetrievingError \u2014 When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls. function varname . debug ( var , *more_vars , prefix='DEBUG: ' , merge=False , repr=True ) </> Print variable names and values. Examples >>> a = 1 >>> b = object >>> print ( f 'a= { a } ' ) # previously, we have to do >>> print ( f ' { a =} ' ) # or with python3.8 >>> # instead we can do: >>> debug ( a ) # DEBUG: a=1 >>> debug ( a , prefix = '' ) # a=1 >>> debug ( a , b , merge = True ) # a=1, b=<object object at 0x2b9a4c89cf00> Parameters var \u2014 The variable to print *more_vars \u2014 Other variables to print prefix (str, optional) \u2014 A prefix to print for each line merge (bool, optional) \u2014 Whether merge all variables in one line or not repr (bool, optional) \u2014 Print the value as repr(var) ? otherwise str(var) function varname . namedtuple ( *args , **kwargs ) </> A shortcut for namedtuple You don't need to specify the typename, which will be fetched from the variable name. So instead of: >>> from collections import namedtuple >>> Name = namedtuple ( 'Name' , [ 'first' , 'last' ]) You can do: >>> from varname import namedtuple >>> Name = namedtuple ([ 'first' , 'last' ]) Parameters *args \u2014 arguments for collections.namedtuple except typename **kwargs \u2014 keyword arguments for collections.namedtuple except typename Returns (type) The namedtuple you desired. class varname . Wrapper ( value , raise_exc=True ) </> A wrapper with ability to retrieve the variable name Examples >>> foo = Wrapper ( True ) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper ( val ) >>> # bar.name == 'bar' >>> # bar.value is val Parameters value (any) \u2014 The value to be wrapped raise_exc (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve Attributes name \u2014 The variable name to which the instance is assigned value \u2014 The value this wrapper wraps","title":"API"},{"location":"api/varname/#varname","text":"</> Dark magics about variable name in python Classes VarnameRetrievingError \u2014 When failed to retrieve the varname </> Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr ) \u2014 Print variable names and values. </> inject ( obj ) (object) \u2014 Inject attribute __varname__ to an object </> inject_varname ( cls , caller , multi_vars , raise_exc ) (Union(type, callable(type: type))) \u2014 Alias of register. Will be deprecated </> namedtuple ( *args , **kwargs ) (type) \u2014 A shortcut for namedtuple </> nameof ( var , *more_vars , caller , full ) (str or (str)) \u2014 Get the names of the variables passed in </> register ( cls , caller , multi_vars , raise_exc ) (Union(type, callable(type: type))) \u2014 A decorator to inject varname attribute to a class </> varname ( caller , ignore , multi_vars , raise_exc ) (Union(str, (str or tuple), nonetype)) \u2014 Get the variable name that assigned by function/class calls </> will ( caller , raise_exc ) (str, optional) \u2014 Detect the attribute name right immediately after a function call. </> class","title":"varname"},{"location":"api/varname/#varnamevarnameretrievingerror","text":"</> Bases Exception BaseException When failed to retrieve the varname function","title":"varname.VarnameRetrievingError"},{"location":"api/varname/#varnamevarname","text":"</> Get the variable name that assigned by function/class calls To debug and specify the right caller and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> import varname >>> varname . DEBUG = True Parameters caller (int, optional) \u2014 The call frame index, indicating where this function is called relative to where the variable is finally retrieved Frames are counted with the ignored ones being excluded. See ignore for frames to be ignored. ignore (list of Union(module, (module, str)), optional) \u2014 A list of modules or tuples of module and qualname that you want to ignore for the intermediate calls. For example, ['module'] ignores all intermediate calls from module and its submodules, but [(module, 'func')] only ignores the calls (qual)named func from module . By default, all calls from varname and builtin modules (in sys.builtin_module_names ) are ignored. Note that the qualname in the module should exist and be unique. multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS). If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Returns (Union(str, (str or tuple), nonetype)) The variable name, or None when raise_exc is False and we failed to retrieve the variable name. A tuple or a hierarchy (tuple of tuples) of variable names when multi_vars is True . Raises UserWarning \u2014 When there are multiple target in the assign node. (e.g: a = b = func() , in such a case, b == 'a' , may not be the case you want) VarnameRetrievingError \u2014 When there is invalid variables or invalid number of variables used on the LHS; or when we are unable to retrieve the variable name and raise_exc is set to True . function","title":"varname.varname"},{"location":"api/varname/#varnamewill","text":"</> Detect the attribute name right immediately after a function call. Examples >>> class AwesomeClass : >>> def __init__ ( self ): >>> self . will = None >>> def permit ( self ): >>> self . will = will () >>> if self . will == 'do' : >>> # let self handle do >>> return self >>> raise AttributeError ( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do ( self ): >>> if self . will != 'do' : >>> raise AttributeError ( \"You don't have permission to do\" ) >>> return 'I am doing!' >>> awesome = AwesomeClass () >>> # AttributeError: You don't have permission to do >>> awesome . do () >>> # AttributeError: Should do something with AwesomeClass object >>> awesome . permit () >>> awesome . permit () . do () == 'I am doing!' Parameters caller (int, optional) \u2014 At which stack this function is called. raise_exc (bool, optional) \u2014 Raise exception we failed to detect Returns (str, optional) The attribute name right after the function call If there is no attribute attached and raise_exc is False Raises VarnameRetrievingError \u2014 When raise_exc is True and we failed to detect the attribute name (including not having one) function","title":"varname.will"},{"location":"api/varname/#varnameregister","text":"</> A decorator to inject varname attribute to a class Parameters caller (int, optional) \u2014 The call stack index, indicating where this class is instantiated relative to where the variable is finally retrieved multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS). If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Examples >>> @varname . register >>> class Foo : pass >>> foo = Foo () >>> # foo.__varname__ == 'foo' Returns (Union(type, callable(type: type))) The wrapper function or the class itself if it is specified explictly. function","title":"varname.register"},{"location":"api/varname/#varnameinject_varname","text":"</> Alias of register. Will be deprecated function","title":"varname.inject_varname"},{"location":"api/varname/#varnameinject","text":"</> Inject attribute __varname__ to an object Examples >>> class MyList ( list ): >>> pass >>> a = varname . inject ( MyList ()) >>> b = varname . inject ( MyList ()) >>> a . __varname__ == 'a' >>> b . __varname__ == 'b' >>> a == b >>> # other methods not affected >>> a . append ( 1 ) >>> b . append ( 1 ) >>> a == b Parameters obj (object) \u2014 An object that can be injected Raises VarnameRetrievingError \u2014 When __varname__ is unable to be set as an attribute Returns (object) The object with varname injected function","title":"varname.inject"},{"location":"api/varname/#varnamenameof","text":"</> Get the names of the variables passed in Examples >>> a = 1 >>> nameof ( a ) # 'a' >>> b = 2 >>> nameof ( a , b ) # ('a', 'b') >>> x = lambda : None >>> x . y = 1 >>> nameof ( x . y , full = True ) # 'x.y' Note This function works with the environments where source code is available, in other words, the callee's node can be retrieved by executing . In some cases, for example, running code from python shell/REPL or from exec / eval , we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Parameters var \u2014 The variable to retrieve the name of *more_vars \u2014 Other variables to retrieve the names of caller (int, optional) \u2014 The depth of the caller (this function) is called. This is useful if you want to wrap this function. Note that the calls from varname and builtin modules are ignored. full (bool, optional) \u2014 Whether report the full path of the variable. For example: nameof(a.b.c, full=True) give you a.b.c instead of c Returns (str or (str)) The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises VarnameRetrievingError \u2014 When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls. function","title":"varname.nameof"},{"location":"api/varname/#varnamedebug","text":"</> Print variable names and values. Examples >>> a = 1 >>> b = object >>> print ( f 'a= { a } ' ) # previously, we have to do >>> print ( f ' { a =} ' ) # or with python3.8 >>> # instead we can do: >>> debug ( a ) # DEBUG: a=1 >>> debug ( a , prefix = '' ) # a=1 >>> debug ( a , b , merge = True ) # a=1, b=<object object at 0x2b9a4c89cf00> Parameters var \u2014 The variable to print *more_vars \u2014 Other variables to print prefix (str, optional) \u2014 A prefix to print for each line merge (bool, optional) \u2014 Whether merge all variables in one line or not repr (bool, optional) \u2014 Print the value as repr(var) ? otherwise str(var) function","title":"varname.debug"},{"location":"api/varname/#varnamenamedtuple","text":"</> A shortcut for namedtuple You don't need to specify the typename, which will be fetched from the variable name. So instead of: >>> from collections import namedtuple >>> Name = namedtuple ( 'Name' , [ 'first' , 'last' ]) You can do: >>> from varname import namedtuple >>> Name = namedtuple ([ 'first' , 'last' ]) Parameters *args \u2014 arguments for collections.namedtuple except typename **kwargs \u2014 keyword arguments for collections.namedtuple except typename Returns (type) The namedtuple you desired. class","title":"varname.namedtuple"},{"location":"api/varname/#varnamewrapper","text":"</> A wrapper with ability to retrieve the variable name Examples >>> foo = Wrapper ( True ) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper ( val ) >>> # bar.name == 'bar' >>> # bar.value is val Parameters value (any) \u2014 The value to be wrapped raise_exc (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve Attributes name \u2014 The variable name to which the instance is assigned value \u2014 The value this wrapper wraps","title":"varname.Wrapper"},{"location":"api/source/varname/","text":"SOURCE CODE varname DOCS \"\"\"Dark magics about variable name in python\"\"\" import ast import dis import sys import inspect import warnings from typing import Callable , List , Union , Tuple , Any , Optional from types import FrameType , CodeType , ModuleType from collections import namedtuple as standard_namedtuple from functools import wraps , lru_cache import executing __version__ = \"0.5.6\" __all__ = [ \"VarnameRetrievingError\" , \"varname\" , \"will\" , \"inject_varname\" , \"register\" , \"inject\" , \"nameof\" , \"namedtuple\" , \"Wrapper\" , \"debug\" ] # To show how the desired frame is selected and other frames are skipped DEBUG = False class VarnameRetrievingError ( Exception ): DOCS \"\"\"When failed to retrieve the varname\"\"\" def varname ( DOCS caller : int = 1 , ignore : Optional [ List [ Union [ ModuleType , Tuple [ ModuleType , str ]]] ] = None , multi_vars : bool = False , raise_exc : bool = True ) -> Optional [ Union [ str , Tuple [ Union [ str , tuple ]]]]: \"\"\"Get the variable name that assigned by function/class calls To debug and specify the right caller and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> import varname >>> varname.DEBUG = True Args: caller: The call frame index, indicating where this function is called relative to where the variable is finally retrieved Frames are counted with the ignored ones being excluded. See `ignore` for frames to be ignored. ignore: A list of modules or tuples of module and qualname that you want to ignore for the intermediate calls. For example, `['module']` ignores all intermediate calls from `module` and its submodules, but `[(module, 'func')]` only ignores the calls (qual)named `func` from `module`. By default, all calls from `varname` and builtin modules (in `sys.builtin_module_names`) are ignored. Note that the qualname in the module should exist and be unique. multi_vars: Whether allow multiple variables on left-hand side (LHS). If `True`, this function returns a tuple of the variable names, even there is only one variable on LHS. If `False`, and multiple variables on LHS, a `VarnameRetrievingError` will be raised. raise_exc: Whether we should raise an exception if failed to retrieve the name. Returns: The variable name, or `None` when `raise_exc` is `False` and we failed to retrieve the variable name. A tuple or a hierarchy (tuple of tuples) of variable names when `multi_vars` is `True`. Raises: VarnameRetrievingError: When there is invalid variables or invalid number of variables used on the LHS; or when we are unable to retrieve the variable name and `raise_exc` is set to `True`. UserWarning: When there are multiple target in the assign node. (e.g: `a = b = func()`, in such a case, `b == 'a'`, may not be the case you want) \"\"\" ignore = ignore or [] _check_qualname ( ignore ) # Skip one more frame, as it is supposed to be called # inside another function node = _get_node ( caller + 1 , ignore , raise_exc = raise_exc ) if not node : if raise_exc : raise VarnameRetrievingError ( \"Unable to retrieve the ast node.\" ) return None node = _lookfor_parent_assign ( node ) if not node : if raise_exc : raise VarnameRetrievingError ( 'Failed to retrieve the variable name.' ) return None if isinstance ( node , ast . AnnAssign ): target = node . target else : # Need to actually check that there's just one # give warnings if: a = b = func() if len ( node . targets ) > 1 : warnings . warn ( \"Multiple targets in assignment, variable name \" \"on the very left will be used.\" , UserWarning ) target = node . targets [ 0 ] names = _node_name ( target ) if not isinstance ( names , tuple ): names = ( names , ) if multi_vars : return names if len ( names ) > 1 : raise VarnameRetrievingError ( f \"Expecting a single variable on left-hand side, got { len ( names ) } .\" ) return names [ 0 ] def will ( caller : int = 1 , raise_exc : bool = True ) -> Optional [ str ]: DOCS \"\"\"Detect the attribute name right immediately after a function call. Examples: >>> class AwesomeClass: >>> def __init__(self): >>> self.will = None >>> def permit(self): >>> self.will = will() >>> if self.will == 'do': >>> # let self handle do >>> return self >>> raise AttributeError( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do(self): >>> if self.will != 'do': >>> raise AttributeError(\"You don't have permission to do\") >>> return 'I am doing!' >>> awesome = AwesomeClass() >>> # AttributeError: You don't have permission to do >>> awesome.do() >>> # AttributeError: Should do something with AwesomeClass object >>> awesome.permit() >>> awesome.permit().do() == 'I am doing!' Args: caller: At which stack this function is called. raise_exc: Raise exception we failed to detect Returns: The attribute name right after the function call If there is no attribute attached and `raise_exc` is `False` Raises: VarnameRetrievingError: When `raise_exc` is `True` and we failed to detect the attribute name (including not having one) \"\"\" node = _get_node ( caller + 1 , raise_exc = raise_exc ) if not node : if raise_exc : raise VarnameRetrievingError ( \"Unable to retrieve the frame.\" ) return None # try to get node inst.attr from inst.attr() node = node . parent # see test_will_fail if not isinstance ( node , ast . Attribute ): if raise_exc : raise VarnameRetrievingError ( \"Function `will` has to be called within \" \"a method/property of a class.\" ) return None # ast.Attribute return node . attr def register ( DOCS cls : type = None , * , caller : int = 1 , multi_vars : bool = False , raise_exc : bool = True ) -> Union [ type , Callable [[ type ], type ]]: \"\"\"A decorator to inject __varname__ attribute to a class Args: caller: The call stack index, indicating where this class is instantiated relative to where the variable is finally retrieved multi_vars: Whether allow multiple variables on left-hand side (LHS). If `True`, this function returns a tuple of the variable names, even there is only one variable on LHS. If `False`, and multiple variables on LHS, a `VarnameRetrievingError` will be raised. raise_exc: Whether we should raise an exception if failed to retrieve the name. Examples: >>> @varname.register >>> class Foo: pass >>> foo = Foo() >>> # foo.__varname__ == 'foo' Returns: The wrapper function or the class itself if it is specified explictly. \"\"\" if cls is not None : # Used as @register directly return register ( caller = caller , multi_vars = multi_vars , raise_exc = raise_exc )( cls ) # Used as @register(multi_vars=..., raise_exc=...) def wrapper ( cls ): \"\"\"The wrapper function to wrap a class and inject `__varname__`\"\"\" orig_init = cls . __init__ @wraps ( cls . __init__ ) def wrapped_init ( self , * args , ** kwargs ): \"\"\"Wrapped init function to replace the original one\"\"\" self . __varname__ = varname ( caller = caller - 1 , multi_vars = multi_vars , raise_exc = raise_exc ) orig_init ( self , * args , ** kwargs ) cls . __init__ = wrapped_init return cls return wrapper def inject_varname ( DOCS cls : type = None , * , caller : int = 1 , multi_vars : bool = False , raise_exc : bool = True ) -> Union [ type , Callable [[ type ], type ]]: \"\"\"Alias of register. Will be deprecated\"\"\" warnings . warn ( \"Decorator inject_varname will be removed in 0.6.0. \" \"Use varname.register to decorate your class.\" , DeprecationWarning ) return register ( cls , caller = caller , multi_vars = multi_vars , raise_exc = raise_exc ) def inject ( obj : object ) -> object : DOCS \"\"\"Inject attribute `__varname__` to an object Examples: >>> class MyList(list): >>> pass >>> a = varname.inject(MyList()) >>> b = varname.inject(MyList()) >>> a.__varname__ == 'a' >>> b.__varname__ == 'b' >>> a == b >>> # other methods not affected >>> a.append(1) >>> b.append(1) >>> a == b Args: obj: An object that can be injected Raises: VarnameRetrievingError: When `__varname__` is unable to be set as an attribute Returns: The object with __varname__ injected \"\"\" warnings . warn ( \"Function inject will be removed in 0.6.0. Use \" \"varname.register to decorate your class.\" , DeprecationWarning ) vname = varname ( caller = 0 ) try : setattr ( obj , '__varname__' , vname ) except AttributeError : raise VarnameRetrievingError ( 'Unable to inject __varname__.' ) from None return obj def nameof ( var , * more_vars , # pylint: disable=unused-argument DOCS caller : int = 1 , full : Optional [ bool ] = None ) -> Union [ str , Tuple [ str ]]: \"\"\"Get the names of the variables passed in Examples: >>> a = 1 >>> nameof(a) # 'a' >>> b = 2 >>> nameof(a, b) # ('a', 'b') >>> x = lambda: None >>> x.y = 1 >>> nameof(x.y, full=True) # 'x.y' Note: This function works with the environments where source code is available, in other words, the callee's node can be retrieved by `executing`. In some cases, for example, running code from python shell/REPL or from `exec`/`eval`, we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Args: var: The variable to retrieve the name of *more_vars: Other variables to retrieve the names of caller: The depth of the caller (this function) is called. This is useful if you want to wrap this function. Note that the calls from varname and builtin modules are ignored. full: Whether report the full path of the variable. For example: `nameof(a.b.c, full=True)` give you `a.b.c` instead of `c` Returns: The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises: VarnameRetrievingError: When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls. \"\"\" node = _get_node ( caller , raise_exc = True ) if not node : # We can't retrieve the node by executing. # It can be due to running code from python/shell, exec/eval or # other environments where sourcecode cannot be reached # make sure we keep it simple (only single variable passed and no # full passed) to use _bytecode_nameof if not more_vars and full is None : # don't need caller + 1 # since this is happening inside varname # and will be ignored by default return _bytecode_nameof ( caller ) # We are anyway raising exceptions, no worries about additional burden # of frame retrieval again # may raise exception, just leave it as is frame = _get_frame ( caller ) source = frame . f_code . co_filename if source == '<stdin>' : raise VarnameRetrievingError ( \"Are you trying to call nameof in REPL/python shell? \" \"In such a case, nameof can only be called with single \" \"argument and no keyword arguments.\" ) if source == '<string>' : raise VarnameRetrievingError ( \"Are you trying to call nameof from exec/eval? \" \"In such a case, nameof can only be called with single \" \"argument and no keyword arguments.\" ) raise VarnameRetrievingError ( \"Source code unavailable, nameof can only retrieve the name of \" \"a single variable, and argument `full` should not be specified.\" ) ret = [] for arg in node . args : if not full or isinstance ( arg , ast . Name ): ret . append ( _node_name ( arg )) else : # traverse the node to get the full name: nameof(a.b.c) # arg: # Attribute(value=Attribute(value=Name(id='a', ctx=Load()), # attr='b', # ctx=Load()), # attr='c', # ctx=Load()) full_name = [] while not isinstance ( arg , ast . Name ): if not isinstance ( arg , ast . Attribute ): raise VarnameRetrievingError ( 'Can only retrieve full names of ' '(chained) attribute calls by nameof.' ) full_name . append ( arg . attr ) arg = arg . value # now it is an ast.Name full_name . append ( arg . id ) ret . append ( '.' . join ( reversed ( full_name ))) return ret [ 0 ] if not more_vars else tuple ( ret ) def debug ( var , * more_vars , DOCS prefix : str = 'DEBUG: ' , merge : bool = False , repr : bool = True ) -> None : # pylint: disable=redefined-builtin \"\"\"Print variable names and values. Examples: >>> a = 1 >>> b = object >>> print(f'a={a}') # previously, we have to do >>> print(f'{a=}') # or with python3.8 >>> # instead we can do: >>> debug(a) # DEBUG: a=1 >>> debug(a, prefix='') # a=1 >>> debug(a, b, merge=True) # a=1, b=<object object at 0x2b9a4c89cf00> Args: var: The variable to print *more_vars: Other variables to print prefix: A prefix to print for each line merge: Whether merge all variables in one line or not repr: Print the value as `repr(var)`? otherwise `str(var)` \"\"\" var_names = nameof ( var , * more_vars , full = True ) if not isinstance ( var_names , tuple ): var_names = ( var_names , ) variables = ( var , * more_vars ) name_and_values = [ f \" { var_name } = { variables [ i ] !r} \" if repr else f \" { var_name } = { variables [ i ] } \" for i , var_name in enumerate ( var_names )] if merge : print ( f \" { prefix }{ ', ' . join ( name_and_values ) } \" ) else : for name_and_value in name_and_values : print ( f \" { prefix }{ name_and_value } \" ) def namedtuple ( * args , ** kwargs ) -> type : DOCS \"\"\"A shortcut for namedtuple You don't need to specify the typename, which will be fetched from the variable name. So instead of: >>> from collections import namedtuple >>> Name = namedtuple('Name', ['first', 'last']) You can do: >>> from varname import namedtuple >>> Name = namedtuple(['first', 'last']) Args: *args: arguments for `collections.namedtuple` except `typename` **kwargs: keyword arguments for `collections.namedtuple` except `typename` Returns: The namedtuple you desired. \"\"\" warnings . warn ( \"Shortcut for namedtuple is deprecated and \" \"will be removed in 0.6.0. Use the standard way instead.\" , DeprecationWarning ) typename = varname ( raise_exc = True ) return standard_namedtuple ( typename , * args , ** kwargs ) class Wrapper : DOCS \"\"\"A wrapper with ability to retrieve the variable name Examples: >>> foo = Wrapper(True) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper(val) >>> # bar.name == 'bar' >>> # bar.value is val Args: value: The value to be wrapped raise_exc: Whether to raise exception when varname is failed to retrieve Attributes: name: The variable name to which the instance is assigned value: The value this wrapper wraps \"\"\" def __init__ ( self , value : Any , raise_exc : bool = True ): # This call is ignored, since it's inside varname self . name = varname ( caller = 0 , raise_exc = raise_exc ) self . value = value def __str__ ( self ) -> str : return repr ( self . value ) def __repr__ ( self ) -> str : return ( f \"< { self . __class__ . __name__ } \" f \"(name= { self . name !r} , value= { self . value !r} )>\" ) def _check_qualname ( ignore_list : List [ Union [ ModuleType , Tuple [ ModuleType , str ]]] ) -> None : \"\"\"Check if a qualname refers to a unique object. If multiple or none, raise an error \"\"\" assert isinstance ( ignore_list , list ), ( f \"A list expected for 'ignore', got { type ( ignore_list ) } \" ) for ignore_elem in ignore_list : if not isinstance ( ignore_elem , tuple ): continue module , qualname = ignore_elem source = executing . Source . for_filename ( module . __file__ , module . __dict__ ) nobj = list ( source . _qualnames . values ()) . count ( qualname ) assert nobj == 1 , ( f \"Qualname { qualname !r} in { module . __name__ !r} doesn't exist or \" \"refers to multiple objects.\" ) def _debug ( msg : str , frame : Optional [ FrameType ] = None ) -> None : \"\"\"Print the debug message\"\"\" if not DEBUG : return if frame is not None : frameinfo = inspect . getframeinfo ( frame ) msg = ( f ' { msg } [In { frameinfo . function !r} at ' f ' { frameinfo . filename } : { frameinfo . lineno } ]' ) sys . stderr . write ( f '[ { __name__ } ] DEBUG: { msg } \\n ' ) def _get_frame ( caller : int , ignore : Optional [ List [ Union [ ModuleType , Tuple [ ModuleType , str ]]] ] = None ) -> FrameType : \"\"\"This function makes sure that we get the desired frame, by caller and ignroe. The caller is the desired stack we want after excluding the frames we want to ignore. By default, this module (varname) and the builtin modules will be ignored. The frame_index defaults to 1 to exclude the calls from inside this module. \"\"\" # Use loop instead of recursion to avoid creating additional stacks try : # We are at least skipping 2 frames: # one is this function, the other is any varname API that uses this # Don't bother to test them, just simply skip. frame_index = 2 while caller > 0 : frame = sys . _getframe ( frame_index ) # loot at next frame anyway at next iteration frame_index += 1 module = inspect . getmodule ( frame ) # exect = executing.Source.executing(frame) if module is sys . modules [ __name__ ]: _debug ( 'Skipping frame from varname' , frame ) continue if module and module . __name__ in sys . builtin_module_names : # havn't find a way to compose a test for this, skip for now _debug ( 'Skipping builtin module' , frame ) # pragma: no cover continue # pragma: no cover if ignore and ( module in ignore or ( module , executing . Source . for_frame ( frame ) . code_qualname ( frame . f_code ) ) in ignore ): _debug ( 'Ignored' , frame ) continue if ignore and module and '.' in module . __name__ : # if asyncio specified, asyncio.runners, asyncio.events, etc # should be all ignored modnames = module . __name__ . split ( '.' )[: - 1 ] if any ( sys . modules [ '.' . join ( modnames [: i + 1 ])] in ignore for i , _ in enumerate ( modnames )): _debug ( 'Ignored' , frame ) continue caller -= 1 if caller > 0 : _debug ( f 'Skipping ( { caller - 1 } more to skip)' , frame ) else : _debug ( 'Gotcha!' , frame ) return frame except Exception as exc : raise VarnameRetrievingError from exc def _get_node ( caller : int , ignore : Optional [ List [ Union [ ModuleType , Tuple [ ModuleType , str ]]] ] = None , raise_exc : bool = True ) -> Optional [ ast . AST ]: \"\"\"Try to get node from the executing object. This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge `reticulate`, where only first frame is kept. When the node can not be retrieved, try to return the first statement. \"\"\" try : frame = _get_frame ( caller , ignore ) except VarnameRetrievingError : return None exect = executing . Source . executing ( frame ) if exect . node : return exect . node if exect . source . text and exect . source . tree and raise_exc : raise VarnameRetrievingError ( \"Couldn't retrieve the call node. \" \"This may happen if you're using some other AST magic at the \" \"same time, such as pytest, ipython, macropy, or birdseye.\" ) return None def _lookfor_parent_assign ( node : ast . AST ) -> Optional [ ast . Assign ]: \"\"\"Look for an ast.Assign node in the parents\"\"\" while hasattr ( node , 'parent' ): node = node . parent if isinstance ( node , ( ast . AnnAssign , ast . Assign )): return node return None def _node_name ( node : ast . AST ) -> Optional [ Union [ str , Tuple [ Union [ str , tuple ]]]]: \"\"\"Get the node node name. Raises VarnameRetrievingError when failed \"\"\" if isinstance ( node , ast . Name ): return node . id if isinstance ( node , ast . Attribute ): return node . attr if isinstance ( node , ( ast . List , ast . Tuple )): return tuple ( _node_name ( elem ) for elem in node . elts ) raise VarnameRetrievingError ( f \"Can only get name of a variable or attribute, \" f \"not { ast . dump ( node ) } \" ) def _bytecode_nameof ( caller : int = 1 ) -> str : \"\"\"Bytecode version of nameof as a fallback\"\"\" frame = _get_frame ( caller ) return _bytecode_nameof_cached ( frame . f_code , frame . f_lasti ) @lru_cache () def _bytecode_nameof_cached ( code : CodeType , offset : int ) -> str : \"\"\"Cached Bytecode version of nameof We are trying this version only when the sourcecode is unavisible. In most cases, this will happen when user is trying to run a script in REPL/ python shell, with `eval`, or other circumstances where the code is manipulated to run but sourcecode is not available. \"\"\" instructions = list ( dis . get_instructions ( code )) ( current_instruction_index , current_instruction ), = ( ( index , instruction ) for index , instruction in enumerate ( instructions ) if instruction . offset == offset ) if current_instruction . opname not in ( \"CALL_FUNCTION\" , \"CALL_METHOD\" ): raise VarnameRetrievingError ( \"Did you call nameof in a weird way?\" ) name_instruction = instructions [ current_instruction_index - 1 ] if not name_instruction . opname . startswith ( \"LOAD_\" ): raise VarnameRetrievingError ( \"Argument must be a variable or attribute\" ) name = name_instruction . argrepr if not name . isidentifier (): raise VarnameRetrievingError ( f \"Found the variable name { name !r} which is obviously wrong. \" \"This may happen if you're using some other AST magic at the \" \"same time, such as pytest, ipython, macropy, or birdseye.\" ) return name","title":"varname"}]}